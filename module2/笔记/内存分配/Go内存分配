Go语言的内存分配基本与TCMalloc一致：
    分级与TCMalloc一致：
        mheap -> mCentral -> mcache of P

    但是一个size class对应两个span class，一个存指针，一个存直接引用（存直接引用的span无需GC）
    在mcentral中每个span维护了两个链表：none empty，empty；当mcache向mcentral申请内存时会先去non empty里面去找，non empty里面保存的是有可用的page的
    mheap里面不再是链表形式，而是维护了一个树状结构（排序二叉树，按照span class做了一个排序），
        当申请内存时，他会把这些内存初始化，然后初始化的时候会存在一个排序二叉树里面，为了查找时更快
        free：是维护的刚从VirtualMemory申请过来的内存
        scav：GC回来的内存

内存回收
    引用计数：
        维护一个对象，这个对象维护一个计数器，每被引用计数器加一，当引用该对象的对象被销毁时，计数器减一
        优点：对象可以很快回收
        缺点：无法循环引用
    
    标记清除：（Go）
        从根变量开始遍历所有引用的对象，引用的对象标记为被引用，没有标记的回收
        优点：解决计数引用的缺点
        缺点：需要STW，即要暂停程序运行

    分代收集：
        按照生命周期进行划分不同的代空间

    mspan：垃圾回收数据结构
        allocBits：记录了每块内存分配情况 （分配内图）
        gcmarkBits：记录了内存引用的情况，标记对每块内存进行标记，有对象的引用的内存标记为1，没有的标记为0 （标记位图）
        这两个位图的数据结构是完全一致的，标记结束则进行垃圾回收。回收时将allocBits指向gcmarkBits，标记过的则存在，未标记的则回收
        具体做法是 把标记位覆盖到分配位上去，标记位上为真正活跃的内存片段